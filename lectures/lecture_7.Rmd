---
title: "MT611 - Quantitative Research Methods"
subtitle: "Lecture 7: Transformations and Visualisations in R with the {tidyverse}"
author: "Damien Dupré"
date: "Dublin City University"
output:
  xaringan::moon_reader:
    css: ["default", "metropolis", "metropolis-fonts", "css/custom_design.css"]
    lib_dir: libs
    nature:
      beforeInit: "libs/cols_macro.js"
      highlightStyle: zenburn
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include = FALSE}
# general options --------------------------------------------------------------
options(
  scipen = 999,
  htmltools.preserve.raw = FALSE
)
set.seed(42)
# chunk options ----------------------------------------------------------------
knitr::opts_chunk$set(
  cache.extra = knitr::rand_seed, 
  message = FALSE, 
  warning = FALSE, 
  error = FALSE, 
  echo = TRUE,
  cache = FALSE,
  comment = "", 
  fig.align = "center", 
  fig.retina = 3
  )
# libraries --------------------------------------------------------------------
library(tidyverse)
library(knitr)
library(kableExtra)
library(fontawesome)
library(norris)
library(tweetrmd)
library(countdown)
library(gapminder)
# functions --------------------------------------------------------------------
# https://bookdown.org/yihui/rmarkdown-cookbook/font-color.html#using-an-r-function-to-write-raw-html-or-latex-code

colorize <- function(x, color) {
  sprintf("<span style='color: %s;'>%s</span>", color, x)
  }
```

---

class: inverse, mline, center, middle

# 1. Coding in RStudio

---

# R so far

We have already seen how to:

- Use RStudio Cloud
- Install, load and use packages
- Run R code in R Script or R Markdown files
- Use keyboard shortcuts: `Ctrl` & `Enter` (Win) / `Command` & `Enter` (Mac)
- Create object with the assignment arrow `<-` sign
- Upload and read data in RStudio Cloud

---

# Rstudio Cloud

In your webrowser (Chrome, Firefox, ...):

1. Open these same slides on a tab to copy-paste the examples
  - From Loop: Lectures > Lecture 7
  - Or from the URL: https://damien-dupre.github.io/mt611/lectures/lecture_7

2. In another tab, go to: https://rstudio.cloud/
  - Sign in or Sign up (if not already done)
  - In your workspace, Click "Untitled Project" or "New Project" (if not already done) 

```{r out.width='100%'}
knitr::include_graphics("https://miro.medium.com/max/1400/1*JBHNRwGr3ZiyBzYWpvH6zg.png")
```

---

# RStudio IDE

When you open RStudio, you’ll see the following 3 windows (also called panes):

* **Console**: where the results are printed
* **Workspace**: where the objects are stored
* **Files, Plots, Package, Help and Viewer**: where data science materials are

```{r out.width='70%'}
knitr::include_graphics("img/rstudio_ide.png")
```

The last window **Code Editor** needs to be opened by clicking:

 * *File* > *New File* > *R Script*

---

# Console: R’s Heart

Where R actually evaluates code:

* Ready to process code if the prompt is `>` . 
* If a command is incomplete at the end of a line, the prompt `+` is displayed
* If the console shows a red icon in the top right corner, the console is currently processing your script

```{r out.width = '30%'}
knitr::include_graphics("img/r_console.png")
```

You can execute code by typing it directly into the Console. However, it won’t be saved. And if you make a mistake you will have to re-type everything all over again. 

Instead, it’s better to write all your code in a document called the **Code Editor**.

---

# Environment: R’s Brain

The Environment tab of this panel shows you the names of all the data objects (like vectors, matrices, and data frames) that you have defined in your current R session. 

You can also see information like the number of observations and rows in data objects. 

```{r out.width = '50%'}
knitr::include_graphics("img/r_environment.png")
```

---

# Files / Plots / Packages / Help

* The **Files** panel gives you access to the file directory on your hard drive.

* The **Plots** panel shows all your plots. There are buttons for opening the plot in a separate window and exporting the plot as a pdf or jpeg.

* The **Packages** shows a list of all the R packages installed on the local or remote machine and indicates whether or not they are currently loaded.

* With the **Help** menu for R functions you can access to essential information to use them. Just have a look at some of them by typing `?` followed by the function name such as:

```{r echo=TRUE, eval=FALSE}
?seq
?lm
```

---

# Code Editor: R's Nervous System

It makes the link between all the previous pane and allows to reproduce actions and behaviours.

```{r out.width = '50%'}
knitr::include_graphics("img/rstudio_panes.png")
```

In a R Script, each line corresponds to a command except if:

* A function is spread on multiple lines until the closing brackets
* A `%>%` operator is used to chain multiple commands 
* A `+` operator is used to add multiple layers to a ggplot

All text starting with the symbol `#` is not computed and used as a comment to give information.

---

# Become Expert in R

Because R is free, plenty of free learning materials are available online:

* Video tutorials

* Book tutorials, see for example:
  - [R for Data Science](https://r4ds.had.co.nz/) by Wickham & Grolemund (2017)
  - [A ModernDive into R and the tidyverse](https://moderndive.com/) by Ismay & Kim (2019)
  - [Getting Used to R, RStudio, and R Markdown](https://rbasics.netlify.com/) by Kennedy (2019)
  - [Introduction to Open Data Science](https://ohi-science.org/data-science-training/) by the Ocean Health Index Team (2019)
  
* Interactive tutorials, see for example:
  - [RStudio Primers](https://rstudio.cloud/learn/primers)
  - [R-Bootcamp](https://r-bootcamp.netlify.com)
  - [Introduction to R](https://www.quantargo.com/courses/course-r-introduction)
  - [DCU R tutorials](https://dcu-r-tutorials.netlify.app)

---

# How to solve your pRoblems

1. Look at your error
  * If it's obvious, solve it by yourself
  * If it's not obvious, copy paste the error in google
  
2. Look at your object (`str(ObjectName)`)

3. Look at the function (documentation)

4. Look at the web
  * Google "R how to ..."
  * Stack Overflow

---

class: inverse, mline, center, middle

# 2. Transformations with {dplyr}

---

# Using {dplyr} in the {tidyverse}

The {tidyverse} package is primarily made up of a set of super useful R packages ({ggplot2}, {dplyr}, {purrr}, {tidyr}, {readr}, {tibble}).

It is also a new way of thinking about implementing “tidy” data analysis. 

If you combine tidy thinking with the {tidyverse} packages, you will inevitably become a master of tidy analysis. 

The tidyverse has a very detailed website for more information: https://www.tidyverse.org/.

```{r eval=FALSE, echo=TRUE}
install.packages("tidyverse")
library(tidyverse)
```

---

# {dplyr}'s main functions

There are five **{dplyr}** functions that you will use to do the vast majority of data manipulations:

- `filter()`: Subset observations (pick observations by their values)

- `select()`: Subset variables (pick variables by their names)

- `mutate()`: Make new variables (create new variables with functions of existing variables)

- `summarise()`: Summarise data (collapse many values down to a single summary)

These can all be used in conjunction with `group_by()` which changes the scope of each function from operating on the entire dataset to operating on it group-by-group.

These five functions provide the verbs for a language of data manipulation.

---

# {dplyr}'s main functions

All verbs work similarly:

- `r colorize("The first argument is a dataframe object name", "red")` 
- `r colorize("The subsequent arguments describe how the dataframe is transformed", "green")` 
- `r colorize("The result is a new dataframe", "blue")`

Here is a generic example:

.center[**`r colorize("dataframe_transformed", "blue")` `<-` function_name(`r colorize("dataframe_name", "red")`, `r colorize("transformation", "green")`)**
]

---

# The gapminder dataset

The dataset used today is stored in the {gapminder} package into an object called `gapminder`. 

Each row in this table corresponds to a country at a specific year. For each row, we have 6 columns:

- **country**: Name of country.
- **year**: Year of the observation (between 1952 and 2007).
- **pop**: Number of people living in the country.
- **continent**: Which of the five continents the country is part of. 
- **lifeExp**: Life expectancy in years.
- **gdpPercap**: Gross domestic product (in US dollars).

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

1. Install the package {gapminder} which contains the data gapminder
2. Load the package {gapminder} to access the data
3. Use the function `str()` on the gapminder data 

```{r}
countdown(minutes = 5, warn_when = 60)
```

---

class: title-slide, middle

## The filter() function

---

# The filter() function

You will want to isolate bits of your data; maybe you want to only look at a single country or a few years. R calls this subsetting and `filter()` allows you to subset observations based on their values.

`filter()`'s transformation is a conditional statement, only observations TRUE to the condition are kept.

For example

```{r eval=FALSE, echo=TRUE}
filter(gapminder, country == "Ireland")
```

Importantly, Column/Variable names are not between quotation marks in the Tidyverse whereas the value to filter is
- A Column/Variable is an object containing multiple values inside the data frame object.
- The string "Ireland" does not exist in our environment and will not be saved. It is here just as a value, which explains the quotation marks.

---

# Comparisons

To use filtering effectively, you have to know how to select the observations that you want using the comparison operators. R provides the standard suite: `>`, `>=`, `<`, `<=`, `!=` (not equal), and `==` (exactly equal).

When you’re starting out with R, the easiest mistake to make is to use `=` instead of `==` when testing for equality. When this happens you’ll get an informative error:

```{r eval=FALSE, echo=TRUE}
filter(gapminder, country = "Ireland")
```

```out
Error: Problem with `filter()` input `..1`.
x Input `..1` is named.
ℹ This usually means that you've used `=` instead of `==`.
ℹ Did you mean `country == "Ireland"`?
```

---

# Multiple filters

Whereas the `filter()` can include as many conditions as possible, it is also possible to store the result of the `filter()` function in a new object and then to apply a new filter on this new object.

```{r eval=FALSE, echo=TRUE}
gapminder_ireland <- filter(gapminder, country == "Ireland")

gapminder_ireland_2007 <- filter(gapminder_ireland, year == 2007)
```

A choice is offered to you, you can either overwrite the original object by using the same object name or to use a different object name.

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

1. Be sure that the packages {tidyverse} and {gapminder} are loaded
2. Create a new object that only contains data for France
3. Create a new object using the previous object that only contains data for France in 1982

```{r}
countdown(minutes = 5, warn_when = 60)
```

---

class: title-slide, middle

## The select() function

---

# The select() function

It’s not uncommon to get datasets with hundreds or even thousands of variables. In this case, the first challenge is often narrowing in on the variables you’re actually interested in. 

`select()` allows you to rapidly zoom in on a useful subset using operations based on the names of the variables. 

Again the first argument is the name of the data frame object to process and the following arguments are the name of the columns to keep.

```{r eval=FALSE, echo=TRUE}
select(gapminder, country, year, pop)
```

---

# Keep and remove variables

The `select()` function can not only be used to keep specific variables but it can also be used to remove them from the data frame object. 

To do so, just add the `-` sign in front of the variable name to be removed. For example:

```{r eval=FALSE, echo=TRUE}
gapminder_keep <- select(gapminder, country, year, pop)

gapminder_remove <- select(gapminder, -continent, -lifeExp, -gdpPercap)
```

In the previous example the objects `gapminder_keep` and `gapminder_remove` should have the same number of variable and therefore be equal.

---

# Select and rename variables

While you are keeping only specify variables with `select()`, these variables can also be renamed on the same time. 

The new name has to be first, followed by the `=` sign, and the old name.

Example:

```{r eval=FALSE, echo=TRUE}
select(gapminder, country, population = pop, measure_year = year)
```

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

1/ From the data frame object `gapminder`, select the columns `lifeExp` and `gdpPercap` and rename them as life_expectancy and gdp_per_capita:

```{r eval=FALSE, echo=TRUE}
select(_ _ _, _ _ _ = _ _ _, _ _ _ = _ _ _)
```

2/ From the data frame object `gapminder`, remove the columns `pop` and `year` and assign the result in a new object. The display the value of this object:

```{r eval=FALSE, echo=TRUE}
new_data <- select(_ _ _, -_ _ _, -_ _ _)

new_data
```

```{r}
countdown(minutes = 5, warn_when = 60)
```

---

class: title-slide, middle

## The mutate() function

---

# The mutate() function

Besides selecting sets of existing columns, it’s often useful to add new columns that are functions of existing columns. That’s the job of `mutate()`. 

Once again the first argument is the name of the data frame object to modify, then the second argument is the name of the column to create followed by the `=` sign and the condition creating the new values.

For example we can create a new column called `gdp_total` which contains the values resulting from the multiplication between `pop` and `gdpPercap`:

```{r eval=FALSE, echo=TRUE}
mutate(gapminder, gdp_total = pop * gdpPercap)
```

`mutate()` can also create multiple columns in the same statement, they just have to be separated by a comma `,`.

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

1/ From the data frame object `gapminder`, create a new column called `country_upper` with the function `toupper()` using the column `country`:

```{r eval=FALSE, echo=TRUE}
mutate(_ _ _, _ _ _ = _ _ _(_ _ _))
```

2/ From the data frame object `gapminder`, filter the countries in Europe and their values for 2007. Assign the result to an new object called `europe_2007`. 
Then create a new column called `europe_prop` corresponding to the value of the column `pop` divided by the total population in Europe in 2007.

```{r eval=FALSE, echo=TRUE}
europe_2007 <- filter(_ _ _, _ _ _ == _ _ _ & _ _ _ == _ _ _)

mutate(_ _ _, _ _ _ = _ _ _/_ _ _(_ _ _))
```

```{r}
countdown(minutes = 5, warn_when = 60)
```

---

class: title-slide, middle

## The summarise() function

---

# The summarise() function

The last key verb is `summarise()`. It collapses a data frame to a single row:

```{r eval=FALSE, echo=TRUE}
summarise(gapminder, mean(pop))
summarise(gapminder, sd(pop))
```

The result of `summarise()` is a dataframe, the default header of the summary is the calculation but a new header can be defined by using the `=` sign when summarising the data:

```{r eval=FALSE, echo=TRUE}
summarise(gapminder, m_pop = mean(pop))
summarise(gapminder, sd_pop = sd(pop))
```

Finally, more than one summary can be done inside a `summarise()`:

```{r eval=FALSE, echo=TRUE}
summarise(gapminder, m_pop = mean(pop), sd_pop = sd(pop))
```

---

# The summarise() function

`summarise()` is not terribly useful unless we pair it with `group_by()`. This changes the unit of analysis from the complete dataset to individual groups. Then, when you use the dplyr verbs on a grouped data frame they’ll be automatically applied “by group”. 

For example, if we applied exactly the same code to a data frame grouped by year, we get the average world population per year:

```{r echo=TRUE}
gapminder_by_year <- group_by(gapminder, year)

summarise(gapminder_by_year, mean_pop = mean(pop))
```

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

1/ From the data frame object `gapminder`, summarise the population average with the `mean()` function by `year` and by `continent` by adding the second grouping variable after the first one (use a coma to separate them):

```{r eval=FALSE, echo=TRUE}
gapminder_group <- group_by(_ _ _, _ _ _, _ _ _)

summarise(_ _ _, _ _ _ = _ _ _(_ _ _))
```

2/ From the data frame object `gapminder`, summarise the population standard deviation with the `sd()` function by `year` and by `continent` by adding the second grouping variable after the first one (use a coma to separate them):

```{r eval=FALSE, echo=TRUE}
gapminder_group <- group_by(_ _ _, _ _ _, _ _ _)

summarise(_ _ _, _ _ _ = _ _ _(_ _ _))
```

```{r}
countdown(minutes = 5, warn_when = 60)
```

---

class: title-slide, middle

## The pipe operator %>%

---

# The pipe operator %>%

Imagine that we want to summarise the population average and standard deviation only of Europe. Using what you know about {dplyr}, you might write code like this:

```{r eval=FALSE, echo=TRUE}
gapminder_europe <- filter(gapminder, continent == "Europe")

gapminder_summary_europe <- summarise(gapminder_europe, 
  m_pop = mean(pop),
  sd_pop = sd(pop)
)
```

This code is a little frustrating to write because we have to give each intermediate data frame a name, even though we don’t care about it. Naming things is hard, so this slows down our analysis.

---

# The pipe operator %>% 

There’s another way to tackle the same problem with the pipe, `%>%`:

```{r eval=FALSE, echo=TRUE}
gapminder_summary_europe <- gapminder %>% 
  filter(continent == "Europe") %>% 
  summarise(m_pop = mean(pop), sd_pop = sd(pop))
```

---

# The pipe operator %>%

You can read it as a series of imperative statements: group, then summarise, then filter in the first example and: filter, then summarise in the second example. As suggested by this reading, a good way to pronounce `%>%` when reading code is **“then”**.

```{r eval=FALSE, echo=TRUE}
gapminder_summary_europe <- gapminder %>% 
  filter(continent == "Europe") %>% 
  summarise(m_pop = mean(pop), sd_pop = sd(pop))
```

Becomes

> Create the object "gapminder_summary_europe" from the object "gapminder", then

> Filter all the values exactly equals to "Europe" in the continent variable, then

> Summarise the average population as "m_pop" and the standard deviation as "sd_pop".

---

# The pipe operator %>%

Behind the scenes, `x %>% f()` turns into `f(x)`, and `x %>% f() %>% g()` turns into `g(f(x))` and so on.

The following sequence can be read as:
1. Take `x` then
2. Use it as the input to the function `f()` then
3. Use `f(x)` as the input to the function `g()` then
4. Use `g(f(x))` as the input to the function `h()`

```{r eval=FALSE, echo=TRUE}
x %>% 
  f() %>% 
  g() %>% 
  h()
```

Working with the pipe is one of the key criteria for belonging to the tidyverse. The only exception is {ggplot2}.

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

1/ From the data frame object `gapminder`, summarise the population average with the `mean()` function by `year` and by `continent` by adding the second grouping variable after the first one (use a coma to separate them) and by using the pipe operator:

```{r eval=FALSE, echo=TRUE}
_ _ _ %>% 
  group_by(_ _ _, _ _ _) %>% 
  summarise(_ _ _ = _ _ _(_ _ _))
```

2/ From the data frame object `gapminder`, summarise the population standard deviation with the `sd()` function by `year` and by `continent` by adding the second grouping variable after the first one (use a coma to separate them) and by using the pipe operator:

```{r eval=FALSE, echo=TRUE}
_ _ _ %>% 
  group_by(_ _ _, _ _ _) %>% 
  summarise(_ _ _ = _ _ _(_ _ _))
```

```{r}
countdown(minutes = 5, warn_when = 60)
```

---

class: inverse, mline, center, middle

# 3. Visualistions with {ggplot2}

---

# Using {ggplot2} in the {tidyverse}

The {ggplot2} package, as it provides an easy way to customise your plots.

{ggplot2} is rooted in the data visualisation theory known as the grammar of graphics (Wilkinson 2005).

As a part of the {tidyverse} package, {ggplot2} is loaded when {tidyverse} is loaded as well:

```{r eval=FALSE}
# install.packages("tidyverse") if not done already (check list of packages)
library(tidyverse)
```

---

# The grammar of graphics

**“the grammar of graphics”** (the “gg” in ggplot) defines a set of rules for constructing statistical graphics by combining different types of layers. 

From the last to the first, the layers are :

```{r echo=FALSE}
include_graphics("http://www.lucaliebi.ch/r_books/images/ggplot2.png")
```

---

# Data

In {ggplot2}, the **data** layer is the name of the object that contains the variables to plot.

The visualisation is initiated with the function `ggplot()`

```{r eval=FALSE}
ggplot(data = my_dataframe)
```

Let's try to use the gapminder data:

```{r fig.height=3}
ggplot(data = gapminder)
```

Only a grey frame is displayed: we need to define the axes (aesthetic mapping) and their corresponding layers.

**Then additional, layers are added with the symbol `+`.**

---

# Aesthetic mapping

The **aesthetic mapping** refers to the frame of the plot, `x` for the variable in the x-axis and `y` for the variable in the y-axis. There are many more aesthetics such as `color`, `fill` and `group` but let's focus on the x and y axes for the moment. The mapping is performed by a function in {ggplot2} called `aes()` for aesthetics. 

This is an essential concept to remember, the mapping of a plot (frame axes) is built from aesthetics.

```{r eval=FALSE}
ggplot(data = my_dataframe) +
  aes(x = my_xaxis_variable, y = my_yaxis_variable)
```

--

Again, the arguments names of the `ggplot()` function and layers can be omitted if filled in the right order:

```{r eval=FALSE}
ggplot(my_dataframe) +
  aes(my_xaxis_variable, my_yaxis_variable)
```

Obviously, some type of layers are not suitable for all aesthetics, it depends on how many variables are included and their type (categorical or continuous). 

---

# Aesthetic mapping

.pull-left[
Aesthetic mapping represents not only the variables defined as x-axis and y-axis but also, colours of borders (colors), colours of shapes (fill), shapes ...
]

.pull-right[
```{r eval=FALSE}
ggplot(data = my_dataframe) +
 aes(
    x = my_xaxis_variable, 
    y = my_yaxis_variable,
    color = my_color_variable,
    fill = my_fill_variable,
    shape = my_shape_variable,
    size = my_size_variable
  )
)
```
]


---

# Aesthetic mapping

For example, the following code is adding not only a x- and y-axis to a scatter plot, but also colours to the points:

```{r fig.height=4}
ggplot(data = gapminder) +
  aes(x = gdpPercap, y = lifeExp, color = continent)

```

---

# Geometries

**Geometries**, which are shapes we use to represent our data. There is a dedicated function for every type of shape to plot but all start with `geom_`

|function          |shape    |
|------------------|---------|
|`geom_point()`    |point    |
|`geom_line()`     |line     |
|`geom_bar()`      |bar      |
|`geom_histogram()`|histogram|
|`geom_boxplot()`  |boxplot  |
|...               |...      |

The list is very long but here are the main ones. Multiple **geometries** can be added as layers by using the same `+` symbol. 

---

# Geometries

Example for scatter plots:

```{r eval=FALSE}
ggplot(data = my_dataframe) +
  aes(x = my_xaxis_variable, y = my_yaxis_variable) +
  geom_point() 
```

Example for line graph:

```{r eval=FALSE}
ggplot(data = my_dataframe) +
  aes(x = my_xaxis_variable, y = my_yaxis_variable) +
  geom_line() 
```

Example for bar graph:

```{r eval=FALSE}
ggplot(data = my_dataframe) +
  aes(x = my_xaxis_variable, y = my_yaxis_variable) +
  geom_col() 
```

Note: Not all data is suitable for all types of geometries. It is to you to find the one that corresponds to your data

---

# Geometries Applied to gapminder

Example for scatter plots:

```{r fig.height=4}
ggplot(data = gapminder) +
  aes(x = gdpPercap, y = lifeExp, color = continent) +
  geom_point() 
```

---

# Geometries Applied to gapminder

Example for line graph:

```{r fig.height=4}
ggplot(data = gapminder) +
  aes(x = year, y = lifeExp, color = country) +
  geom_line() +
  guides(color = FALSE) # removes legend because too many countries
```

---

# Geometries Applied to gapminder

Example for bar graph:

```{r fig.height=4}
gapminder_avg_continent_2007 <- gapminder %>% 
  filter(year == 2007) %>% 
  group_by(continent) %>% 
  summarise(m_lifeExp = mean(lifeExp, na.rm = TRUE))

ggplot(data = gapminder_avg_continent_2007) +
  aes(x = continent, y = m_lifeExp, fill = continent) +
  geom_col() 
```

---

# Themes

Now, to make the plot more professional, let's remove that standard grey background using a different theme. 

Many themes come built into the {ggplot2} package. My preference is `theme_bw()` but once you start typing `theme_` a list of options will pop up.

```{r fig.height=4}
ggplot(gapminder) +
  geom_point(aes(x = gdpPercap, y = lifeExp, color = continent)) +
  theme_bw()
```

---

# Themes

Built-in ggplot2 themes includes:

- `theme_bw()`
- `theme_classic()`
- `theme_minimal()`
- `theme_dark()`
- `theme_light()`
- ... 

Try them in the following exercises.

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

Build a ggplot with the `gapminder` dataset and one `geom_boxplot()` layer
which contains the x as `continent`, y as `lifeExp` and color as `continent` 
in its `aes()`. Use a theme of your choice as well:

```{r eval=FALSE}
_ _ _(_ _ _) +
  aes(x = _ _ _, y = _ _ _, color = _ _ _) +
  _ _ _() +
  _ _ _()
```

Build a ggplot with the `gapminder` dataset and one `geom_col()` layer which contains the x as `year`, y as `pop` and fill as `continent` in its `aes()`. Use a theme of your choice as well:

```{r eval=FALSE}
_ _ _(_ _ _) +
  aes(x = _ _ _, y = _ _ _, fill = _ _ _)
  _ _ _() +
  _ _ _()
```

```{r echo=FALSE}
countdown(minutes = 5, warn_when = 60)
```

---

class: title-slide, middle

## Advanced Visualistions with {ggplot2}

---

# Customising Plots

Take a look at the ggplot2 [cheat sheet](https://www.rstudio.com/wp-content/uploads/2016/11/ggplot2-cheatsheet-2.1.pdf), and think of ways you could improve the plot.

<img src="https://d33wubrfki0l68.cloudfront.net/21d683072b0c21cbd9b41fc0e37a587ad26b9525/cbf41/wp-content/uploads/2018/08/data-visualization-2.1.png" width="75%">

---

# Inherited Propriety of Geometries

You can add as many geometry layers as you want, however repeating the mapping for each geometry layer is very redundant. Thankfully, if all your geometry layers are using the same aesthetics mapping, it is possible to include this mapping inside the `ggplot()`, then all the geometry layers will have the same mapping:

```{r fig.height=4, fig.width=12}
ggplot(gapminder, aes(x = year, y = lifeExp, color = country)) +
  geom_point() +
  geom_line() +
  guides(color = FALSE)
```

---

# Facets

Faceting is used when we’d like to split a particular visualisation by the values of another variable. 

This will create multiple copies of the same type of plot with matching x and y axes, but whose content will differ.

For example, suppose we were interested in looking at the evolution of life expectancy by continent from 1952. We could “split” this figure for each continent. In other words, we would plot a scatter plot for each continent separately. 

We do this by adding `facet_wrap(~ continent)` layer.

---

# Facets

```{r fig.height=4}
ggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) +
  geom_point() +
  facet_wrap(~ continent) +
  theme_classic()
```

The tilde is required and you’ll receive the error `Error in as.quoted(facets) : object 'continent' not found` if you don’t include it here.

---

# Facets

We can also specify the number of rows and columns in the grid by using the `nrow` and `ncol` arguments inside of `facet_wrap()`. 

For example, suppose we would like our faceted figure to have 1 rows instead of 2. We simply add an `nrow = 1` argument to `facet_wrap(~ continent)`:

```{r fig.height=3, fig.width=12}
ggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) +
  geom_point() +
  facet_wrap(~ continent, nrow = 1) +
  theme_classic()
```

---

# Labels

Now, let’s capitalise the x and y axis labels and add a main title to the figure. Ggplot has a layer called `labs()` in order to change the name of the axis labels very quickly. `labs()` has at least 3 arguments for us: x, y and title.

```{r fig.height=3, fig.width=12}
ggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) +
  geom_point() +
  facet_wrap(~ continent, nrow = 1) +
  labs(
    x = "Year (from 1952 to 2007)",
    y = "Life Expectancy",
    title = "Evolution of life expectancy from 1952 to 2007 per continent."
  ) +
  theme_classic()
```

---

# Statistics and Special Effects

Instead of creating summaries inside the data frame object, ggplot has some function to calculate and display them automatically. One can say that they are for lazy people but they are so useful!

The first special effect is the `geom_smooth()` layer. `geom_smooth()` is a classic geometry layer but which displays linear and non-linear trends.

```{r fig.height=3, fig.width=12}
ggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~ continent, nrow = 1) +
  theme_classic()
```

---

# Statistics and Special Effects

`geom_smooth()` has one important extra argument called `method`. If method has the value "lm", a linear regression will be shown. If method has the value "loess" or "gam", a non-linear regression will be shown.

```{r fig.height=4, fig.width=12}
ggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~ continent, nrow = 1) +
  theme_classic()
```

---

# Additional Options

```{r fig.height=3, fig.width=12}
ggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) +
  geom_point(alpha = 0.2, size = 1) +
  geom_smooth(method = "lm") +
  facet_wrap(~ continent, nrow = 1) +
  scale_x_continuous(breaks = c(1960, 1980, 2000)) +
  labs(
    x = "Year (from 1952 to 2007)",
    y = "Life Expectancy",
    title = "Evolution of life expectancy from 1952 to 2007 per continent."
  ) +
  theme_classic() +
  theme(text = element_text(size = 20)) +
  guides(color = FALSE)
```

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

Build a ggplot with the `gapminder` dataset and one `geom_boxplot()` layer which contains the x as `continent`, y as `lifeExp` and color as `continent` in its `aes()`. Use `year` as a facet variable, use a theme of your choice as well and changes axises labels:

```{r eval=FALSE}
ggplot(_ _ _) +
  geom_boxplot(...
```

Build a ggplot with the `gapminder` dataset and:

- One `geom_line()` layer which contains the x as `year`, y as `lifeExp` and group as `country` in its `aes()`,
- One `geom_smooth()` layer which contains the x as `year`, y as `lifeExp` and color as `continent` in its `aes()` ,
- One `facet_wrap()` for each continent.

```{r eval=FALSE}
ggplot(_ _ _ , aes(x = _ _ _ , y = _ _ _)) +
  geom_line(...
```

```{r echo=FALSE}
countdown(minutes = 10, warn_when = 60)
```

---
class: title-slide, middle

## Include ggplot in pipes

---

# Include ggplot in pipes

A very powerful way to create figures in R is to use a ggplot at the end of a data transformation pipe.

Indeed, having a data frame object as first argument of the `ggplot()` function is similar to using a pipe operator and chaining it to the `ggplot()` function:

```{r eval=FALSE}
# this classic representation:
ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
  geom_point()

# is the same as:
gapminder %>% 
  ggplot(aes(gdpPercap, lifeExp, color = continent)) +
  geom_point()
```

The layers are still added with the `+` symbol.

In this last code, it is also possible to modify the data frame using `filter()`, `select()`, `mutate()`, and `summarise()`.

---

# Filter to ggplot()

You can easily display only the data for a specific section of you interest. For example, let's filter the data only for Ireland:

```{r fig.height=3, fig.width=12}
gapminder %>% 
  filter(country == "Ireland") %>% 
  ggplot(aes(gdpPercap, lifeExp, color = country)) +
  geom_line()
```

---

# Mutate to ggplot()

If you need to display a variable that has to be created beforehand, you can always include a mutate statement in the chain.

For example, let's create the variable `gdpPercountry` which is the result of the multiplication between countries' population and countries' gdpPercap. Then let's display this information for Ireland and France:

```{r fig.height=3, fig.width=12}
gapminder %>% 
  mutate(gdpPercountry = gdpPercap*pop) %>% 
  filter(country == "Ireland") %>% 
  ggplot(aes(gdpPercountry, lifeExp, color = country)) +
  geom_line()
```

---

# Summary to ggplot()

Finally, one of the most useful possibilities will be to summarise variables per groups and to display this information in figures.

For example, let's create the average population per continent and display how this average evolves with time:

```{r fig.height=3, fig.width=12}
gapminder %>% 
  group_by(year, continent) %>% 
  summarise(m_pop = mean(pop)) %>% 
  ggplot(aes(year, m_pop, color = continent)) +
  geom_line()
```

---

# Summary to ggplot()

We can also compare the sum of the population by continent for the year 2007:

```{r fig.height=3, fig.width=12}
gapminder %>% 
  filter(year == 2007) %>% 
  group_by(continent) %>% 
  summarise(s_pop = sum(pop)) %>% 
  ggplot(aes(continent, s_pop, fill = continent)) +
  geom_col()
```

---
class: inverse, mline, left, middle

<img class="circle" src="https://github.com/damien-dupre.png" width="250px"/>

# Thanks for your attention and don't hesitate to ask any questions!

[`r fa(name = "twitter")` @damien_dupre](http://twitter.com/damien_dupre)  
[`r fa(name = "github")` @damien-dupre](http://github.com/damien-dupre)  
[`r fa(name = "link")` damien-datasci-blog.netlify.app](https://damien-datasci-blog.netlify.app)  
[`r fa(name = "paper-plane")` damien.dupre@dcu.ie](mailto:damien.dupre@dcu.ie)
